# Complexidade de Algoritmos

Este documento apresenta um relatório detalhado sobre a **complexidade de algoritmos**, abordando sua definição, os tipos de complexidade (tempo e espaço), a notação Big O e exemplos práticos. Compreender esses conceitos é fundamental para a escolha de algoritmos eficientes, especialmente em cenários com grandes volumes de dados.

---

## 1. Introdução à Complexidade de Algoritmos

Em ciência da computação, um algoritmo é definido como uma sequência finita de passos bem definidos, utilizados para resolver problemas ou realizar tarefas específicas. A análise da eficiência desses algoritmos torna-se crucial à medida que os problemas se tornam maiores, permitindo avaliar os recursos computacionais (tempo e espaço) consumidos conforme o tamanho da entrada aumenta. Essa compreensão auxilia cientistas e desenvolvedores na escolha do algoritmo mais adequado para cada situação.

---

## 2. Definição de Complexidade de Algoritmos

A **complexidade de um algoritmo** refere-se à medida dos recursos computacionais necessários (tempo de execução e espaço de memória) para executar o algoritmo, expressa como uma função do tamanho da entrada. A análise foca no comportamento assintótico — ou seja, como esses recursos crescem à medida que o tamanho da entrada aumenta. Essa análise é vital para prever o desempenho e comparar diferentes abordagens.

---

## 3. Tipos de Complexidade

A análise da complexidade divide-se principalmente em:

### 3.1. Complexidade de Tempo
- **Definição:** Mede o número de operações elementares realizadas em função do tamanho da entrada.
- **Objetivo:** Comparar algoritmos com base no crescimento do número de operações à medida que 'n' (tamanho da entrada) aumenta.

### 3.2. Complexidade de Espaço
- **Definição:** Mede a quantidade de memória utilizada pelo algoritmo durante sua execução.
- **Objetivo:** Avaliar o espaço ocupado pelos dados de entrada, variáveis auxiliares e estruturas de dados utilizadas.

> Em alguns casos, pode haver uma troca entre tempo e espaço, onde otimizar um pode aumentar o outro.

---

## 4. Notação Big O

### 4.1. Introdução à Notação Big O
A notação Big O é uma ferramenta matemática que descreve o limite superior assintótico da complexidade de tempo ou espaço, focando no termo dominante e ignorando constantes e termos de ordem inferior.

### 4.2. Significado e Importância
- Permite comparar algoritmos de forma padronizada, independente de hardware ou linguagem de programação.
- Facilita a previsão do comportamento de um algoritmo com o aumento do tamanho da entrada.

### 4.3. Regras para Determinar a Complexidade Big O
- Operações básicas (atribuições, operações aritméticas, acesso a arrays) são geralmente O(1).
- Estruturas de controle como loops são analisadas multiplicando a quantidade de iterações pela complexidade das operações internas.
- Em loops aninhados, a complexidade é o produto das complexidades de cada loop.
- Fatores constantes e termos de ordem inferior são ignorados.

### 4.4. Classes de Complexidade Big O
- **O(1):** Constante  
- **O(log n):** Logarítmica  
- **O(n):** Linear  
- **O(n log n):** Linearítmica  
- **O(n²):** Quadrática  
- **O(n³):** Cúbica  
- **O(2^n):** Exponencial  
- **O(n!):** Fatorial  

---

## 5. Exemplos de Algoritmos e Complexidade de Tempo

### 5.1. O(1) - Complexidade Constante
- **Exemplo:** Acesso a um elemento específico de um array ou troca de valores entre duas variáveis.

### 5.2. O(log n) - Complexidade Logarítmica
- **Exemplo:** Busca binária em um array ordenado, onde o problema é dividido em partes menores a cada iteração.

### 5.3. O(n) - Complexidade Linear
- **Exemplo:** Procura pelo menor item em um array não ordenado ou soma de todos os elementos de uma lista.

### 5.4. O(n log n) - Complexidade Linearítmica
- **Exemplo:** Algoritmos de ordenação como Merge Sort, Heap Sort e Quicksort (caso médio).

### 5.5. O(n²) - Complexidade Quadrática
- **Exemplo:** Algoritmos como Bubble Sort e Insertion Sort, que frequentemente usam loops aninhados.

---

## 6. Exemplos de Algoritmos e Complexidade de Espaço

### 6.1. O(1) - Espaço Constante
- **Exemplo:** Algoritmos que utilizam um número fixo de variáveis auxiliares.

### 6.2. O(n) - Espaço Linear
- **Exemplo:** Criação de uma cópia de um array de entrada.

### 6.3. O(n²) - Espaço Quadrático
- **Exemplo:** Representação de uma matriz de adjacência para um grafo, onde a matriz possui dimensões n x n.

---

## 7. Comparação de Complexidade para o Mesmo Problema

A escolha do algoritmo afeta significativamente a eficiência. Dois exemplos comuns:
- **Pesquisa em Array:**  
  - Pesquisa Linear: O(n)  
  - Busca Binária (em array ordenado): O(log n)
- **Ordenação de Array:**  
  - Algoritmos como Bubble Sort, Insertion Sort e Selection Sort: O(n²)  
  - Algoritmos como Merge Sort e Heap Sort: O(n log n)

A tabela abaixo resume a complexidade de alguns algoritmos:

| **Algoritmo**       | **Melhor Caso** | **Caso Médio** | **Pior Caso** |
|---------------------|-----------------|----------------|---------------|
| Bubble Sort         | O(n)            | O(n²)          | O(n²)         |
| Insertion Sort      | O(n)            | O(n²)          | O(n²)         |
| Selection Sort      | O(n²)           | O(n²)          | O(n²)         |
| Merge Sort          | O(n log n)      | O(n log n)     | O(n log n)    |
| Quick Sort          | O(n log n)      | O(n log n)     | O(n²)         |
| Heap Sort           | O(n log n)      | O(n log n)     | O(n log n)    |
| Linear Search       | O(1)            | O(n)           | O(n)          |
| Binary Search       | O(1)            | O(log n)       | O(log n)      |

Essa comparação evidencia como a escolha do algoritmo pode impactar o desempenho, especialmente para entradas grandes.

---

## 8. Impacto das Estruturas de Dados na Complexidade

A organização e o armazenamento dos dados influenciam diretamente a complexidade dos algoritmos:

- **Array:**  
  - Acesso: O(1)  
  - Inserção/Remoção: O(n)
  
- **Lista Ligada:**  
  - Inserção/Remoção (com ponteiro): O(1)  
  - Acesso: O(n)
  
- **Hash Table (ou Dicionário):**  
  - Operações em média: O(1)  
  - Operações no pior caso (colisões): O(n)
  
- **Árvore de Busca Binária Balanceada:**  
  - Operações de busca, inserção e remoção: O(log n)

A escolha adequada da estrutura de dados é crucial para otimizar o desempenho das operações e, consequentemente, a eficiência dos algoritmos.

---

## 9. Complexidade de Algoritmos e Escalabilidade de Software

A eficiência dos algoritmos impacta diretamente a escalabilidade de um software. Algoritmos com alta complexidade (por exemplo, O(n²) ou O(2^n)) podem funcionar bem com dados pequenos, mas tornam-se inviáveis à medida que o volume aumenta. Por outro lado, algoritmos com baixa complexidade (como O(log n) ou O(n)) garantem melhor desempenho e escalabilidade, possibilitando o processamento de grandes quantidades de dados e usuários.

---

## 10. Conclusão

Este relatório destacou a importância da **análise de complexidade de algoritmos** para o desenvolvimento de software eficiente e escalável. A compreensão da notação Big O e a avaliação de diferentes algoritmos e estruturas de dados permitem prever o comportamento do software sob cargas maiores, auxiliando na escolha da abordagem mais adequada para resolver problemas computacionais.

---

## Referências

1. **Análise da Complexidade de Algoritmos: entenda!** - Iugu  
   [Link](https://www.iugu.com/blog/analise-complexidade-algoritmos)

2. **Complexidade de Algoritmos - IME-USP**  
   [Link](https://www.ime.usp.br/~song/mac5710/slides/01complex.pdf)

3. **www.inf.ufrgs.br**  
   [Link](https://www.inf.ufrgs.br/~prestes/Slides/aula1.pdf)

4. **Notação Big O e guia de complexidade de tempo: Intuição e matemática | DataCamp**  
   [Link](https://www.datacamp.com/pt/tutorial/big-o-notation-time-complexity)

5. **Entenda a complexidade algorítmica e notação Big O na...**  
   [Link](https://www.escoladnc.com.br/blog/a-importancia-da-complexidade-algoritmica-e-notacao-big-o-na-programacao/)

6. **O que é escalabilidade de software e serviços? | Lucidchart Blog**  
   [Link](https://www.lucidchart.com/blog/pt/o-que-e-escalabilidade-de-software-e-servicos)

7. **Complexidade Quadrática O(N²) | Wagner Abrantes | GoLang | DIO**  
   [Link](https://www.dio.me/articles/complexidade-quadratica-on2)

8. **Complexidade temporal – Wikipédia**  
   [Link](https://pt.wikipedia.org/wiki/Complexidade_temporal)

9. **Complexidade de tempo – Wikipédia**  
   [Link](https://pt.wikipedia.org/wiki/Complexidade_de_tempo)

10. **Estruturas de dados:**
